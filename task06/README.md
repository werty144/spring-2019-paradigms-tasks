# Общее
Это домашнее задание состоит из трёх задач, в которых вы будете реализовывать
дополнительную функциональность для языка ЯТЬ при помощи шаблона "Посетитель".

Первая задача оценивается в 0 (ноль) баллов и даже её решение не засчитывает тему.
Её корректность требуется для корректности оставшихся задач,
а стиль - для стиля оставшихся задач.

Вторая и третья задачи оцениваются независимо друг от друга в 2.5 балла каждая.
По каждой задаче 50% вы получаете за корректность и ещё 50% за стиль кода.

Все задачи сдаются через систему pull requests на GitHub.

Задачу 1 требуется реализовывать на базе предоставленных файлов `model.py` и `test_model.py`.
Вы также можете использовать в качестве основы свои решения домашнего задания №4 (если зачтены корректность и стиль).

Задачи 2 и 3 требуется реализовать в отдельных файлах.
Пожалуйста, прочитайте раздел "формат сдачи" для подробностей.

# Задача 1: Visitor
Требуется добавить в класс `ASTNode` методы, необходимые согласно шаблону "Посетитель",
а также создать абстрактный базовый класс `ASTNodeVisitor`, содержащий нужные для
работы с AST методы.

## Подробнее
* Вы можете посмотреть на следующие задания, чтобы понять предполагаемые сценарии использования.
  * В частности, все реализации базового класса `ASTNodeVisitor` будут добавлены в следующих заданиях,
    не надо добавлять их в этом.
* Названия методов шаблона "Посетитель" должны соответствовать общепринятым.
* Настоятельно рекомендуется не решать это задачу отдельно от остальных двух: она не даёт баллов
  и следующие две задачи сильно завязаны на её решение.

## Тесты
В этом задании автоматическе тесты не требуются, но вы можете их реализовать в файле `test_model.py`.
Их стиль будет проверяться, но не будет влиять на засчитывание стиля в этой или последующих задачах.
Просто чтобы вы могли попробовать тестировать, если захотите.

## Требования к корректности решения
Если присланные файлы не соответствуют хотя бы одному из условий ниже, решение считается некорректным и оценивается в 0 баллов:

* Должны отсутствовать синтаксические ошибки для Python 3
* `pycodestyle` при запуске без флагов не должен выдавать ошибок и предупреждений
* Все ваши автоматические тесты должны проходить
* Решение этой задачи должно быть в отдельном коммите или серии коммитов
* `ASTNodeVisitor` должен являться ABC в терминологии Python (как `ASTNode`)

# Задача 2: Форматирование кода
В отдельном файле `printer.py` требуется реализовать класс `PrettyPrinter`,
наследующийся от `ASTNodeVisitor` из предыдущей задачи.
Также в этом файле требуется реализовать функцию `pretty_print(program)`,
которая использует `PrettyPrinter`.

В результате вызова `pretty_print` в стандартный поток вывода должна
выводиться программа на языке ЯТЬ, представленная абстрактным синтаксическим
деревом `program` (объект какого-либо класса из домашнего задания №4).
Точный синтаксис описан ниже.

## Пример
Следующий код:
```
pretty_print(FunctionDefinition('main', Function(['arg1'], [
    Read('x'),
    Print(Reference('x')),
    Conditional(
        BinaryOperation(Number(2), '==', Number(3)),
        [
            Conditional(Number(1), [], [])
        ],
        [
            FunctionCall(Reference('exit'), [
                UnaryOperation('-', Reference('arg1'))
            ])
        ],
    ),
])))
```
может вывести такой текст:
```
def main(arg1) {
    read x;
    print x;
    if ((2) == (3)) {
        if (1) {
        }
    } else {
        exit(-(arg1));
    }
}
```

## Подробнее
Вся программа в языке ЯТЬ состоит из последовательности команд (statements).
На вход методу `pretty_print` подается ровно одна команда языка ЯТЬ.
После каждой команды языка (и только после них), кроме заканчивающихся на `}`, нужно выводить символ `;`.
Ниже описано, из чего может состоять команда языка.
Обратите внимание, что одна и та же конструкция может в одном контексте являться командой языка, а в другом — нет, будьте внимательны.

Команда — это одно из следующего списка:
* Арифметическое выражение
* Условное выражение (представляется как объект `Conditional`)
* Определение функции (представляется как объект `FunctionDefinition`)
* Конструкция print (представляется как объект `Print`)
* Конструкция read (представляется как объект `Read`)

Арифметическое выражение — это одно из следующего списка:
* Число (представляется как объект `Number`)
* Имя (представляется как объект `Reference`)
* Бинарная операция (представляется как `BinaryOperation`), аргументами которой являются арифметические выражения
* Унарная операция (представляется как `UnaryOperation`), аргументом которой является арифметические выражение
* Вызов функции (представляется как `FunctionCall`)

В частности, в этой задаче гарантируется, что объект `Function` вне `FunctionDefinition` в программе не встречается.

Таким образом, если известно, что нужно вывести для каждого из использованных в описании выше классов
(`Conditional`, `FunctionDefinition`, `Print`, `Read`, `Number`, `Reference`, `BinaryOperation`, `UnaryOperation` и `FunctionCall`),
то синтаксис языка будет полностью задан. Пройдемся по всему списку.

### `Conditional`
Для объекта `Conditional` необходимо вывести текст следующего вида:
```
if (<condition>) {
    <if true 0>
    <if true 1>
    …
    <if true k>
} else {
    <if false 0>
    <if false 1>
    …
    <if false n>
}
```
где:
* `<condition>` — арифметическое выражение, переданное как параметр condition конструктору Conditional
* `<if true 0>`, ... `<if true k>` — команды языка (т. е. после них нужно выводить `;`, если только они не заканчиваются на `}`), которые переданы как список `if_true` в конструктор Conditional.
  Учтите, что список `if_true` может быть пустым или `None`, в этом случае нужно вывести просто фигурные скобки на отдельных строчках
* `<if false 0>`, ... `<if false n>` предложения языка, которые переданы как список if_false в конструктор Conditional.
  Учтите, что список `if_false` может быть пустым или `None`, в этом случае вы должны полностью опустить else часть

Например, следующий код:
```
pretty_print(Conditional(Number(42), [], []))
```
должен вывести такой текст:
```
if (42) {
}
```

### `FunctionDefinition`
Для объекта класса `FunctionDefinition` необходимо вывести текст следующего вида:
```
def <name>(arg0, arg1, …, argk) {
    <statement 0>
    <statement 1>
    …
    <statement n>
}
```
где:
* `<name>` — имя функции, переданное как параметр `name` в конструктор `FunctionDefinition`
* `arg0`, `arg1`, ..., `argk` — имена формальных параметров, разделенные запятыми (лишних запятых быть не должно), переданные как список `args ` в конструктор Function,
   которая, в свою очередь, передана как параметр `function` в конструктор `FunctionDefinition`
   Учтите, что список формальных параметров может быть пустым, в этом случае нужно вывести просто круглые скобки.
   Гарантируется, что все `FunctionDefinition` в качестве `function` принимают `Function`, а отдельные `Function` в теле программы не встречаются.
* `<statement 0>`, ..., `<statement n>` — команды языка,
   которые образуют тело функции (параметр `body` в конструкторе `Function`).
   Учтите, что тело функции может быть пустым, в этом случае нужно вывести просто фигурные скобки.

Например, следующий код:
```
pretty_print(FunctionDefinition("foo", Function([], [])))
```
должен вывести следующий текст:
```
def foo() {
}
```

### `Print`
Для объекта `Print` нужно вывести текст следующего вида:
```
print <expression>
```
где `<expression>` — это выражение, которое передано как параметр `expr` в конструктор объекта `Print`.

Например, следующий код:
```
pretty_print(Print(Number(42)))
```
должен вывести следующий текст:
```
print 42;
```

### `Read`
Для объекта `Read` нужно вывести текст следующего вида:
```
read <name>
```
где `<name>` — это имя, переданное как параметр `name` в конструктор объекта `Read`.

Например, следующий код:
```
pretty_print(Read('x'))
```
должен вывести следующий текст:
```
read x;
```

### `Number`
Для объекта типа `Number` нужно вывести в десятичном виде число, которое было передано в конструктор.

Например, следующий код:
```
pretty_print(Number(10))
```
должен вывести следующий текст:
```
10;
```

Точка с запятой в конце нужна, так как `pretty_print` принимает на вход команду языка и поэтому должен вывести точку с запятой после него.
Например, в контексте арифметического выражения эта точка с запятой не понадобится.

### `Reference`
Для объекта типа `Reference` необходимо вывести имя (параметр `name`), переданное в конструктор `Reference`.

Например,с ледующий код:
```
pretty_print(Reference('x'))
```
должен вывести следующий текст:
```
x;
```

Точка с запятой нужна в конце по тем же соображениям, что и в случае с `Number`.

### `BinaryOperation`
Для объекта `BinaryOperation` нужно вывести левый операнд, который является арифметическим выражением,
оператор и затем правый операнд, который также является арифметическим выражением, с учетом приоритетов
(т.е. может потребоваться вывести дополнительные круглые скобки).

Приоритеты операций и ассоциативность приведены в таблице (как для бинарных операторов, так и для унарных).
Операции в начале таблицы имеют больший приоритет, чем операции в конце таблицы:

|Оператор|Ассоциативность|
|---|---|
|`-` (унарный минус), `!` (логическое отрицание)|справа-налево|
|`*`, `/`, `%`|слева-направо|
|`-`, `+`|слева-направо|
|`<`, `<=`, `>`, `>=`|слева-направо|
|`==`, `!=`|слева-направо|
|`&&`|слева-направо|
|`\|\|`|слева-направо|

Например, следующий код:

```
add = BinaryOperation(Number(2), '+', Number(3))
mul = BinaryOperation(Number(1), '*', add)
pretty_print(mul)
```

может вывести такой текст:
```
1 * (2 + 3);
```
а может вывести такой текст:
```
((1) * ((2) + (3)));
```
Но не может вывести такой текст:
```
1 * 2 + 3;
```

Точка с запятой в конце нужна по тем же соображениям, что и для `Number`.

### `UnaryOperation`
Вывод для `UnaryOperation` в целом аналогичен выводу для `BinaryOperation`,
есть только одно замечание — используются префиксные унарные операции.

Например, следующий код:

```
pretty_print(UnaryOperation('-', Number(42)))
```
может вывести следующий текст:
```
-42;
```
а может вывести:
```
(-(42));
```

Точка с запятой в конце нужна по тем же соображениям, что и для `Number`.

При этом запрещается выводить несколько унарных операций подряд без скобочек.
Например, следующий код:

```
pretty_print(UnaryOperation('-', UnaryOperation('-', Number(42))));
```
_не может_ вывести такой текст:
```
--42;
```

### `FunctionCall`
Для объекта `FunctionCall` нужно вывести текст следующего вида:
```
<expr>(<arg 0>, <arg 1>, …, <arg n>)
```
где:
* `<expr>` — арифметическое выражение, переданное в конструктор `FunctionCall` как аргумент `fun_expr`
* `<arg 0>`, `<arg 1>`, …, `<arg n>` — список арифметических выражений, переданные в конструктор `FunctionCall`
  как параметр `args`, все выражения разделены запятыми (лишних запятых быть не должно).
  Учтите, что `args` может быть пустым списком, в этом случае нужно вывести пустые круглые скобки.

Например, следующий код:

```
pretty_print(FunctionCall(Reference('foo'), [Number(1), Number(2), Number(3)]))
```
должен вывести следующий текст:
```
foo(1, 2, 3);
```

## Тесты
Требуется при помощи pytest в отдельном файле `test_printer.py`:

1. Для каждого примера из условия проверить корректность вывода, используя напрямую `PrettyPrinter`.
2. Для большого end-to-end примера из условия проверить корректность вывода, используя `pretty_print`.

## Требования к корректности решения
Если присланные файлы не соответствуют хотя бы одному из условий ниже, решение считается некорректным и оценивается в 0 баллов:

* Должны отсутствовать синтаксические ошибки для Python 3
* `pycodestyle` при запуске без флагов не должен выдавать ошибок и предупреждений
* Все ваши автоматические тесты должны проходить
* Решение этой задачи должно быть в отдельном коммите или серии коммитов
* `PrettyPrinter` должен наследоваться от `ASTNodeVisitor`
* В реализации `PrettyPrinter` не используется явная информацию о типах (т.е. функции `isinstance`, `type` и им подобные конструкции языка python, которые позволяют явно проверять тип объекта)
* Вывод должен содержать разумные отступы.
  Синтаксис языка этого не требует, но мы это будем проверять (т. е. тела функций и списки предложений в Condtional должны иметь больший отступ, чем окружающий их контекст)
* Для отступов используйте либо пробелы либо табуляции, но не мешайте оба символа вместе
* Точка с запятой ставится только после предложений языка
* Сам `PrettyPrinter` не может ничего выводить в стандартный поток вывода
* Вы можете, но не обязаны, объявлять дополнительные классы и функции

# Задача 3: Сворачивание констант
В отдельном файле `folder.py` требуется реализовать класс `ConstantFolder`,
наследующийся от `ASTNodeVisitor` из задачи 1.

Также в этом файле требуется реализовать функцию `fold_constants(program)`,
которая использует `ConstantFolder`.

Функция `fold_constants` должна возвращать _новое_ синтаксическое дерево,
построенное на основе параметра `program` так, чтобы в нем не осталось операций вида:

* `BinaryOperation(Number, AnyBinOp, Number)`, где `Number` — какой-либо объект класса `Number`, а `AnyBinOp` — любая бинарная операция из списка допустимых бинарных операций
* `UnaryOperation(AnyUnOp, Number)`, где `AnyUnOp` — любая операция из списка допустимых унарных операций
* `BinaryOperation(Number(0), '*', Reference)`, где `Number(0)` — объект класса `Number`, который содержит значение `0`, а `Reference` — любой объект класса `Reference`
* `BinaryOperation(Reference, '*', Number(0))`
* `BinaryOperation(Reference(name), ‘-’, Reference(name))`, где `Reference(name)` - объект класса Reference, содержащий имя `name`

но при этом семантически "эквивалентное" исходному дереву `program`.

## Пример
Если у вас решены все задачи, то следующий код:
```
pretty_print(fold_constants(
    BinaryOperation(
        Number(10),
        '-',
        UnaryOperation(
            '-',
            BinaryOperation(
                Number(3),
                '+',
                BinaryOperation(
                    Reference('x'),
                    '-',
                    Reference('x')
                )
            )
        )
     )
))
```
должен вывести следующий текст (с точностью до скобок):
```
13;
```

## Тесты
Требуется при помощи pytest в отдельном файле `test_folder.py`:

1. Для каждой из пяти операции из условия, которую требуется сократить, имеется один отдельный тест, проверяющий корректность.
2. Для большого end-to-end примера из условия имеется тест, проверяющий корректность.

Обратите внимание, что просто вызвать `evaluate()` для проверки корректности недостаточно: требуется
также проверить внутреннюю структуру полученной программы.

Не следует использовать `pretty_print` для проверки: это черезчур сильная зависимость.

## Требования к корректности решения
Если присланные файлы не соответствуют хотя бы одному из условий ниже, решение считается некорректным и оценивается в 0 баллов:

* Должны отсутствовать синтаксические ошибки для Python 3
* `pycodestyle` при запуске без флагов не должен выдавать ошибок и предупреждений
* Все ваши автоматические тесты должны проходить
* Решение этой задачи должно быть в отдельном коммите или серии коммитов
   * Если вы решите определить `ASTNode.__eq__` для тестирования, то сделайте это в отдельном коммите
* `ConstantFolder` должен наследоваться от `ASTNodeVisitor`
* В реализации `ConstantFolder` не используется явная информацию о типах (т.е. функции `isinstance`, `type` и им подобные конструкции языка python, которые позволяют явно проверять тип объекта),
  кроме как внутри самих методов шаблона "посетитель" для классов `BinaryOperation` и `UnaryOperation`
* Вызовы `ConstantFolder` и `fold_constants` не меняют переданные им параметры
* Вы можете, но не обязаны, объявлять дополнительные классы и функции

# Формат сдачи
Если возникают **любые** непонятки с форматом сдачи (даже простые и мелкие) - пишите преподавателю!
Мы не хотим, чтобы вы не сдали просто потому что кто-то не очень хорошо рассказал Git или дал мало практики :)

* Вы работаете в своём собственном fork'е этого репозитория на GitHub
    * Его структура неважна
    * Чтобы внести изменения из нашего `master` в ваш форк, вам требуется в вашем клоне:
        1. `git remote get-url origin` — проверить, что `remote origin` указывает на ваш репозиторий
        1. `git remote add upstream https://github.com/yeputons/spring-2019-paradigms-tasks.git` — добавить наш репозиторий в качестве ещё одного `remote` с именем `upstream`
        1. `git fetch upstream` — загрузить себе в клон все ветки из нашего репозитория
        1. `git checkout master && git status` — переключиться на ветку `master` и проверить, что она в точности соответствует нашему репозиторию.
           Если это не так (например, вы выполняли домашнее задание 6 сразу в `master`), рекомендуется создать в этой точке отдельную ветку,
           а `master` сдвинуть на `upstream/master` и сделать форс-пуш.
           При этом могут "сломаться" ваши старые pull request для домашнего задания 6, будьте осторожны и спросите, если что-то непонятно.
        1. `git merge --ff-only upstream/master` — смёржить изменения из нашего репозитория в ваш клон.
           Ключ `--ff-only` убедится, что этот мёрж можно сделать так, что наши ветки `master` в точности совпадут, в том числе по истории и хэшам коммитов.
           Это необходимо для красивых pull request.
        1. `git push origin master`
    * Один из возможных способов работы:
        1. Ответвить свою ветку `task06-visitor` от ветки `master`, синхронизированной с нашим репозиторием.
        1. В отдельном pull request сдать задачу 1.
        1. Параллельно с этим от ветки `task06-visitor` ответвить `task06-tasks` и работать
           в ней над задачами 2 и 3.
        1. _После_ получения корректности и стиля по `task06-visitor` сделать rebase ветки `task06-tasks`
           и открыть соответствующий pull request для задач 2 и 3.
* Для сдачи домашнего задания откройте pull request в ветку `master` нашего репозитория
* Pull request должен удовлетворять следующим требованиям, иначе он не будет проверен:
  * Название: `Task06-YYY, GroupXX, Фамилия Имя`, где `YYY` — подможество сдаваемых в pull request задач.
    * Например, в `Task06-13, Group09, Суворов Егор` будут сдаваться задачи 1 и 3
    * Не допускаются сокращения, перестановка слов, отсутствие запятой, пробелов или написание имени транслитом
  * Отсутствуют merge conflicts
  * В сумме за все коммиты (вкладка "Files Changed") отсутствуют временные файлы вроде `.*.swp`, настройки среды вроде `.idea` и прочий мусор.
    Разрешается добавлять новые файлы только если это требуется заданием.
    * Если вам хочется добавить `.gitignore`, добавьте его [конкретно на вашем компьютере](https://help.github.com/en/articles/ignoring-files#create-a-global-gitignore)
      при помощи `git config --global core.excludesfile` или [конкретно в вашем клоне](https://help.github.com/en/articles/ignoring-files#explicit-repository-excludes)
      через файл `.git/info/exclude`
  * Ни в одном из коммитов не смешаны изменения, относящиеся к разным задачам
  * В описании pull request упомянут ваш преподаватель:
    для `18.Б09-пу` — `@yeputons`, для `18.Б10-пу` — `@edgarzhavoronkov`
* Вы можете открывать разные pull request для разных задач, но в каждый момент времени может
  быть открыто не более одного pull request
  Если вам хочется добавить решение новой задачи, а pull request уже открыт - добавьте в него коммиты
  и измените название соответствующим образом
* Вопросы следует задавать либо по почте, либо открыв Issue в репозитории в произвольной форме и с названием содержащим вопрос, начинающимся с `Task 06:`
* Для сдачи задания отправлять письмо не требуется, достаточно открытия Pull Request по установленной форме
* Для проверки преподаватель назначает себя reviewer и отправляет вам review прямо на GitHub
  * Approved означает полное засчитывание упомянутых в pull request задач по корректности и стилю
  * Changes requested означает, что что-то надо доделать (при этом могут быть уже зачтены какие-то задачи или может быть зачтена корректность)
* Если вам захотелось исправить решение после прохождения review, вам требуется:
  * Добавить один или более коммитов с исправлениями
    * При этом запрещается переписывать историю, которую уже видел преподаватель на момент проверки, если только это не было обговорено в явном виде
    * В процессе исправлений вы можете переписывать историю добавленных коммитов (которые преподаватель ещё не видел)
  * Оставить в pull request комментарий `исправлено` с упоминанием вашего преподавателя.
    Например: `@yeputons, исправлено`.
    До появления комментария считается, что вы в процессе исправления, и pull request не проверяется
* Если вам захотелось исправить решение до прохождения review, но после открытия pull request или после комментария `исправлено`,
  требования такие же: добавляете новые коммиты, старые не переписываете, в конце оставляете ещё один комментарий
* После вердикта `Approved` или прохождения жёсткого дедлайна pull request закрывается.
  Если вы хотите досдать следующие задачи, требуется открыть новый
* Для засчитывания стиля и корректности задачи 1 (visitor) преподаватель записывает хэш коммита, в котором это произошло.
  Все последующие попытки сдачи задач 2 и 3 должны включать в себя этот коммит.
  Другими словами, не надо делать три отдельные ветки и копировать файл `model.py` туда-сюда:
  либо одна ветка со всеми решениями, либо базовая для visitor и от неё растут решения задач, изредка получая merge или rebase
  (с учётом ограничений выше)
* Вы можете переиспользовать ваш корректный и стильный код из задания 4 в этом (например, чтобы заработал `evaluate` и его
  можно было использовать в тестах).
  Для этого в первом коммите ветки скопируйте свои решения поверх `model.py` и `test_model.py`.
  * Запрещается копировать свои решения из задания 4 после первого коммита ветки.
  * Также запрещается использовать решения, если в них не была зачтена корректность или стиль.
* Запрещается добавлять код на верхний уровень всех файлов, за исключением объявлений процедур, функций, констант, классов и импортов

Таким образом, примерная структура коммитов может выглядеть так:
```
upstream/master
      ^
      |
Add model.py, test_model.py from task04
      ^
      |
Solve visitor  <-- Открыт pull request, получены замечания
      ^     ^
      |     |
Fix visitor |  <-- Ветка task06-visitor, ожидается проверка
            |
       Add printer.py
            ^
            |
       Add folder.py  <-- Ветка task06-tasks
```
После засчитывания `task06-visitor` делаем rebase и получаем такую картину:
```
upstream/master
      ^
      |
Add model.py, test_model.py from task04
      ^
      |
Solve visitor  <-- Открыт pull request, получены замечания
      ^
      |
Fix visitor    <-- Ветка task06-visitor, approved, pull request закрыт
      ^
      |
Add printer.py
      ^
      |
Add folder.py  <-- Ветка task06-tasks после rebase, открыт новый pull request
```

# Сроки сдачи
|   | `18.Б09-пу` | `18.Б10-пу` |Максимальное количество баллов при сдаче в срок
|---|---|---|---|
|Дата выдачи|Пятница, 29.03.2019|Пятница, 29.03.2019|   |
|Мягкий дедлайн|Суббота, 06.04.2019, 22:59|Суббота, 06.04.2019, 22:59|5|
|Жёсткий дедлайн|Четверг, 18.04.2019, 22:59|Четверг, 18.04.2019, 22:59|2.5|
