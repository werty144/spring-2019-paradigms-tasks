# Содержание
1. [Содержание](#содержание)
1. [Общее](#общее)
1. [Задание](#задание)
    1. [Подробнее](#подробнее)
    1. [Тесты](#тесты)
1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
1. [Формат сдачи](#формат-сдачи)
1. [Сроки сдачи](#сроки-сдачи)

# Общее

В этом домашнем задании вам предлагается познакомиться с примитивами синхронизации из POSIX Threads
и реализовать с их помощью потокобезопасную очередь с блокирующим ожиданием элементов (что-то вроде канала из Rust).
Здесь всего одна задача, которая оценивается в 5 баллов, из них 50% вы получаете за корректность и 50% за стиль.

Для решения используется подмножество C++, близкое к языку C.
В частности, мы не используем классы, конструкторы, деструкторы и RAII, а используем структуры
с набором отдельных функций, ручные вызовы деструкторов и прочее веселье.
Чтобы было больше похоже на C: в C++ скорее бы использовались не POSIX Threads,
а `<thread>` из C++11.

# Задание

В этой папкет лежит CMake-проект с заготовкой для многопоточной очереди и некоторыми тестами.
Вам требуется закончить реализацию, дописать тест, а также добавить его автоматический запуск в
файл `.travis.yml` в _корне_ этого репозитория.
Все необходимые для изменения места в этой папке помечены комментарием `// TODO`.

## Подробнее

Все исходные файлы находятся в папке `src/`.
В папке `doctest/` находится библиотека для написания автоматических тестов.

Вам уже дана реализация обычной (не потокобезопасной) очереди в файлах `queue.h` и `queue.cpp`,
а тесты для неё написаны в файле `queue_test.cpp`.
Очередь состоит из opaque-структуры `Queue` и функций `queue_*()`, которые позволяют с ней работать.

В файлах `tsqueue.h`, `tsqueue.cpp` и `tsqueue_test.cpp` написаны заглушки для вашей
потокобезопасной очереди: структура `ThreadsafeQueue` и функции `threadsafe_queue_*()` для работы с ней.
При решении задания следует не реализовывать очередь с нуля, а использовать предоставленную `Queue`.

Обратите внимание, что метод `empty()` в интерфейсе потокобезопасной очереди отсутствует и реализовывать его не надо.
Возвращаемое им значение для многопоточной очереди было бы невозможно разумно использовать:
после возврата значения реальное состояние очереди уже могло быть изменено другим потоком.

Для решения задачи вам требуется выполнить следующие шаги:
1. Добавьте в `.travis.yml` в корне этого репозитория запуск теста `tsqueue_test` после запуска `queue_test` в аналогичном формате.
   Сейчас он там отсутствует, потому что не проходит из-за не до конца выполненного задания.
2. Скомпилируйте проект и проверьте, что `queue_test` отрабатывает без ошибок, т.е. обычная очередь реализована правильно.
3. Прочитайте реализацию обычной очереди в `queue.h`, `queue.cpp` и пример использования в `queue_test.cpp`.
   Убедитесь, что вам понятна каждая строчка.
4. Прочитайте предложенный интерфейс в `tsqueue.h` и пример использование в `tsqueue_test.cpp`.
   Убедитесь, что вам понятна каждая строчка.
5. Реализуйте необходимые функции в `tsqueue.cpp`.
   * Скорее всего, вам также потребуется изменить `tsqueue.h`, чтобы добавить нужные поля в `ThreadsafeQueue`.
   * При удалении `// TODO` удалите также и `static_cast<void>()`, которые используются, чтобы заглушить предупреждения компилятора о неиспользуемых переменных.
6. Допишите тест в `tsqueue_test.cpp`, в котором присутствуют `// TODO`.
   В этом тесте описано, что должно происходить.
   Если возникают вопросы — спрашивайте.
7. Проверьте, что все тесты проходят: скомпилируйте проект и запустите выполняемые файлы `queue_test` и `tsqueue_test`.

Вы можете изменять только те части кода, которые помечены `// TODO`.
Если хочется изменить что-то ещё — напишите, обсудим.

## Тесты

В представленной реализации уже имеется несколько автоматических тестов.
Вам не требуется добавлять свои собственные, однако требуется не сломать имеющиеся,
а также дописать тест `ThreadsafeQueue multithreaded ping-pong`.

# Советы
* Чтобы автоматически переформатировать весь код, выполните команду `clang-format -i -style=file src/*` из текущей папки
* CMake — это система для генерации проектов на C++ для разных компиляторов.
  Запустите в этой папке команду `cmake .`, чтобы сгенерировать проект под
  компилятор по умолчанию на вашей системе.
  Например, под Linux вы на выходе получите `Makefile`, который можно запустить командой `make`,
  а под Windows вы наверняка получите проект для Visual Studio.
* Предоставленные тесты написаны при помощи библиотеки [doctest](https://github.com/onqtam/doctest),
  инструкцию к ней вы можете найти [здесь](https://github.com/onqtam/doctest/blob/master/doc/markdown/tutorial.md).
  * Макрос `CHECK()` при некорректном условии продолжает работу тестов, а макрос `REQUIRE()` при некорректном условии роняет программу.
    Лучше использовать `CHECK()`, если только это не приведёт к очевидному undefined behaviour или зависанию тестов.

Если у вас не компилируется, работает медленно или вообще происходит что-то непонятное — не стесняйтесь спрашивать нас, что делать.
Некоторые ошибки может быть трудно отловить самостоятельно в первый раз.

# Требования к корректности решения

Если присланные файлы не соответствуют хотя бы одному из условий ниже, решение считается некорректным и оценивается в 0 баллов:

* Тест вызов теста `tsqueue_test` добавлен в `.travis.yml`
* Строгость предупреждений и диагностик в `CMakeFiles.txt` не понижена
* Реализован ping-pong тест
* Реализовано блокирующее ожидание элементов в `threadsafe_queue_wait_and_pop`, не нагружающее процессор
  (при помощи conditional variable)
* Отсутствуют утечки памяти и race condition                                                                           	
* Отсутствуют заглушения автопроверки стиля и предупреждений компилятора
* Все проверки на Travis проходят:
  * Все тесты собираются без ошибок и предупреждения
  * Все тесты корректно отрабатывают, в том числе под `valgrind`
  * Файлы не изменяются при форматировании [clang-format](https://clang.llvm.org/docs/ClangFormat.html)
* Места в этой папке, не помеченные `// TODO`, оставлены без изменений

# Формат сдачи
Если возникают **любые** непонятки с форматом сдачи (даже простые и мелкие) - пишите преподавателю!
Мы не хотим, чтобы вы не сдали просто потому что кто-то не очень хорошо рассказал Git или дал мало практики :)

Требования стандартные (см. task08), название для pull request: `Task09, GroupXX, Фамилия Имя`.

# Сроки сдачи
|   | `18.Б09-пу` | `18.Б10-пу` |Максимальное количество баллов при сдаче в срок
|---|---|---|---|
|Дата выдачи|20.04.2019|20.04.2019||
|Мягкий дедлайн|27.04.2019 22:59|27.04.2019 22:59|5|
|Жёсткий дедлайн|04.05.2019 22:59|04.05.2019 22:59|2.5|
